"use strict";
const path_1 = require("path");
const language_service_1 = require("./language-service");
const logger_1 = require("./logger");
const module_loader_1 = require("./module-loader");
const svelte_snapshots_1 = require("./svelte-snapshots");
function init(modules) {
    function create(info) {
        const logger = new logger_1.Logger(info.project.projectService.logger);
        if (!isSvelteProject(info.project.getCompilerOptions())) {
            logger.log('Detected that this is not a Svelte project, abort patching TypeScript');
            return info.languageService;
        }
        logger.log('Starting Svelte plugin');
        const snapshotManager = new svelte_snapshots_1.SvelteSnapshotManager(modules.typescript, info.project.projectService, logger);
        patchCompilerOptions(info.project);
        (0, module_loader_1.patchModuleLoader)(logger, snapshotManager, modules.typescript, info.languageServiceHost, info.project);
        return (0, language_service_1.decorateLanguageService)(info.languageService, snapshotManager, logger);
    }
    function getExternalFiles(project) {
        if (!isSvelteProject(project.getCompilerOptions())) {
            return [];
        }
        // Needed so the ambient definitions are known inside the tsx files
        const svelteTsPath = (0, path_1.dirname)(require.resolve('svelte2tsx'));
        const svelteTsxFiles = [
            './svelte-shims.d.ts',
            './svelte-jsx.d.ts',
            './svelte-native-jsx.d.ts'
        ].map((f) => modules.typescript.sys.resolvePath((0, path_1.resolve)(svelteTsPath, f)));
        return svelteTsxFiles;
    }
    function patchCompilerOptions(project) {
        var _a;
        const compilerOptions = project.getCompilerOptions();
        // Patch needed because svelte2tsx creates jsx/tsx files
        compilerOptions.jsx = modules.typescript.JsxEmit.Preserve;
        // detect which JSX namespace to use (svelte | svelteNative) if not specified or not compatible
        if (!((_a = compilerOptions.jsxFactory) === null || _a === void 0 ? void 0 : _a.startsWith('svelte'))) {
            // Default to regular svelte, this causes the usage of the "svelte.JSX" namespace
            // We don't need to add a switch for svelte-native because the jsx is only relevant
            // within Svelte files, which this plugin does not deal with.
            compilerOptions.jsxFactory = 'svelte.createElement';
        }
    }
    function isSvelteProject(compilerOptions) {
        // Add more checks like "no Svelte file found" or "no config file found"?
        const isNoJsxProject = (!compilerOptions.jsx || compilerOptions.jsx === modules.typescript.JsxEmit.Preserve) &&
            (!compilerOptions.jsxFactory || compilerOptions.jsxFactory.startsWith('svelte')) &&
            !compilerOptions.jsxFragmentFactory &&
            !compilerOptions.jsxImportSource;
        try {
            const isSvelteProject = typeof compilerOptions.configFilePath !== 'string' ||
                require.resolve('svelte', { paths: [compilerOptions.configFilePath] });
            return isNoJsxProject && isSvelteProject;
        }
        catch (e) {
            // If require.resolve fails, we end up here
            return false;
        }
    }
    return { create, getExternalFiles };
}
module.exports = init;
